## List-binarysearch
### 二分查找
#### leetcode.704  
- 链接<https://leetcode.cn/problems/binary-search/>  
- 解题方法：二分查找模板（有序数组）
```
bool check(int x) // 检查x是否满足某种性质
int bsearch_1(int l, int r){
    while (l < r){
        int mid = l + r >> 1;
        if (check(mid)) r = mid;
        else l = mid + 1;
    }
    return l;
}

int bsearch_2(int l, int r){
    while (l < r){
        int mid = l + r + 1>> 1;
        if (check(mid)) l = mid;
        else r = mid - 1;
    }
    return l;
}
```
- leetcode解题代码
```
class Solution {
public:
    int search(vector<int>& nums, int target) {
        int l = 0, r = nums.size() - 1;
        while (l < r){
            int mid = (l + r) / 2;
            if (nums[mid] >= target) r = mid;
            else l = mid + 1;
        }
        if (nums[l] == target) return l;
        return -1;
    }
};
```
- ACM模式调试

输入  
第一行输入两个数n，target  
n表示数组中数的个数，target表示目标值  
第二行表示数组
```
5 9
-1 0 3 5 9 12
```
输出
```
4
```
调试代码
```
#include <iostream>
#include <vector>

using namespace std;

int main(){
    int n, target;
    vector<int> nums(6);
    cin >> n >> target;
    for (int i = 0; i < n; i ++) cin >> nums[i];
    
    int l = 0, r = nums.size() - 1;
    while (l < r){
        int mid = (l + r) / 2;
        if (nums[mid] >= target) r = mid;
        else l = mid + 1;
    }
    if (nums[l] == target) cout << l;
    else cout << -1;
    return 0;
}
```
#### leetcode.35  
- 链接<https://leetcode.cn/problems/search-insert-position/>  
- 解题方法：注意这里与上一题的区别在于需要特判，如果目标值大于数组最后一位则返回数组长度
- leetcode解题代码
```
class Solution {
public:
    int searchInsert(vector<int>& nums, int target) {
        int n = nums.size();
        if (target > nums[n - 1]) return n;
        int l = 0, r = n - 1;
        while (l < r){
            int mid = (l + r) / 2;
            if (nums[mid] >= target) r = mid;
            else l = mid + 1;
        }
        return l;
    }
};
```
- ACM模式调试 和上题类似

#### leetcode.69  
- 链接<https://leetcode.cn/problems/sqrtx/submissions/>  
- 解题方法：本题题意类似于找到最大的y使得y^2<=x，所以使用第二个模板
- leetcode解题代码
```
class Solution {
public:
    int mySqrt(int x) {
        long l = 0, r = x;// long防止越界
        while (l < r){
            int mid = l + r + 1 >> 1;
            if (mid <= x / mid) l = mid;// mid * mid会越界
            else r = mid - 1;
        }
        return r;
    }
};
```
- ACM模式调试  

输入一个数x
```
4
```
输出
```
2
```
调试代码
```
#include <iostream>

using namespace std;

int main(){
    int x;
    cin >> x;
    
    long l = 0, r = x;// long防止越界
    while (l < r){
        int mid = l + r + 1 >> 1;
        if (mid <= x / mid) l = mid;// mid * mid会越界
        else r = mid - 1;
    }
    cout << r << endl;
    return 0;
}
```
#### leetcode.367  
- 链接<https://leetcode.cn/problems/valid-perfect-square/>  
- 解题方法：与上题类似，注意数组越界
- leetcode解题代码
```
class Solution {
public:
    bool isPerfectSquare(int num) {
        long l = 1, r = num;
        while (l < r){
            int mid = l + r + 1 >> 1;
            if (mid <= num / mid) l = mid;
            else r = mid - 1;
        }
        return r * r == num;
    }
};
```
- ACM模式调试代码 和上题类似

#### leetcode.34
- 链接<https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/>  
- 解题方法：找到数组的二段性，利用模板一找到左侧第一个target的下标，利用模板二找到右侧最后一个target的下标  
对于第一个target，[5, 7, 7, 8]，nums[mid] < target  
对于最后一个target，[8, 10]，nums[mid] > target  
- leetcode解题代码
```
class Solution {
public:
    vector<int> searchRange(vector<int>& nums, int target) {

        int l = 0, r = nums.size() - 1;
        while (l < r)
        {
            int mid = (l + r) / 2;
            if (nums[mid] < target) l = mid + 1;
            else r = mid;
        }
        if (nums[l] != target) return {-1, -1};

        int L = l;

        l = 0, r = nums.size() - 1;
        while (l < r)
        {
            int mid = (l + r + 1) / 2;
            if (nums[mid] > target) r = mid - 1;
            else l = mid;
        }
        return {L, r};
    }
};
```
- ACM模式调试

输入
第一行输入两个数n，target  
n表示数组中数的个数，target表示目标值  
第二行表示数组
```
6 8
5 7 7 8 8 10
```
输出
```
3 4 
```
调试代码
```
#include <iostream>
#include <vector>
using namespace std;

int main(){
    int n, target;
    vector<int> nums(6);
    cin >> n >> target;
    for (int i = 0; i < n; i ++) cin >> nums[i];
    
    vector<int> res;
    int l = 0, r = nums.size() - 1;
    while (l < r)
    {
        int mid = (l + r) / 2;
        if (nums[mid] < target) l = mid + 1;
        else r = mid;
    }
    if (nums[l] != target) cout << -1 << -1 << endl;
    res.push_back(l);
    int L = l;

    l = 0, r = nums.size() - 1;
    while (l < r)
    {
        int mid = (l + r + 1) / 2;
        if (nums[mid] > target) r = mid - 1;
        else l = mid;
    }
    res.push_back(l);
    for (auto c: res){
        cout << c << ' ';
    }
    return 0;
}
```
解题参考：<https://www.acwing.com/>  
刷题顺序：<https://www.programmercarl.com/>